/**
 * Reads WASM binaries from @jsquash packages and generates a TypeScript
 * file with base64-encoded constants. This avoids network fetches at
 * runtime inside Figma's sandboxed plugin UI.
 */
import { readFileSync, writeFileSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const root = resolve(__dirname, '..');

const wasmFiles = [
  {
    name: 'MOZJPEG_ENC_WASM',
    path: resolve(root, 'node_modules/@jsquash/jpeg/codec/enc/mozjpeg_enc.wasm'),
  },
  {
    name: 'MOZJPEG_DEC_WASM',
    path: resolve(root, 'node_modules/@jsquash/jpeg/codec/dec/mozjpeg_dec.wasm'),
  },
  {
    name: 'OXIPNG_WASM',
    path: resolve(root, 'node_modules/@jsquash/oxipng/codec/pkg/squoosh_oxipng_bg.wasm'),
  },
];

let output = `// Auto-generated by scripts/encode-wasm.mjs — do not edit manually.\n\n`;

for (const { name, path } of wasmFiles) {
  const bytes = readFileSync(path);
  const b64 = bytes.toString('base64');
  output += `export const ${name}_BASE64 = "${b64}";\n\n`;
  console.log(`  ${name}: ${bytes.length} bytes → ${b64.length} chars base64`);
}

output += `export function base64ToArrayBuffer(base64: string): ArrayBuffer {\n`;
output += `  const binary = atob(base64);\n`;
output += `  const bytes = new Uint8Array(binary.length);\n`;
output += `  for (let i = 0; i < binary.length; i++) {\n`;
output += `    bytes[i] = binary.charCodeAt(i);\n`;
output += `  }\n`;
output += `  return bytes.buffer;\n`;
output += `}\n`;

const outPath = resolve(root, 'src/wasm-data.ts');
writeFileSync(outPath, output);
console.log(`\nWrote ${outPath} (${(output.length / 1024).toFixed(0)} KB)`);
